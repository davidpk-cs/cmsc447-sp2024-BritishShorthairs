<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Production Side</title>
  <style>
    canvas {
      border: 1px solid black;
    }
    .toolbox {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      background-color: #f4f4f4;
      padding: 10px;
      display: flex;
      justify-content: center;
    }
    .toolbox button {
      margin: 0 10px;
    }
    #interface {
      display: none; /* hide by default */
      width: 150px;
      height: 500px;
      background-color: rgb(255, 245, 172);
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 20px;
      border-radius: 10px;
      border-top: 5px solid #000;
      /* init pos */
      top: 300px; 
      left: 900px; 
    }
  </style>
</head>
<body>
  <p id="money">Money: 100000</p>
  <canvas id="canvas" width="720" height="600"></canvas>
  <div class="toolbox">
    <button onclick="setCurrentTool('steel')">Steel Source</button>
    <button onclick="setCurrentTool('copper')">Copper Source</button>
    <button onclick="setCurrentTool('storage')">Storage</button>
    <button onclick="setCurrentTool('constructor')">Constructor</button>
    <button onclick="setCurrentTool('autoshop')">Autoshop</button>
    <button onclick="setCurrentTool('conveyor')">Conveyor Belt</button>
    <button onclick="setCurrentTool('mouse')">Mouse</button>
    <button onclick="setCurrentTool('delete')">Delete Building</button>
  </div>

  <!-- Interface elements -->
  <div id="interface"></div>

  <script src="info.js"></script>
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const gridSize = 40; // Size of each grid cell in pixels
    const width = 18;  // Number of columns
    const height = 15; // Number of rows

    const buildings = [];
    const conveyorBelts = [];
    const movingItems = []; // Tracks items moving along conveyors
    let currentTool = null; // Current tool/building selected
    let firstClick = null; // Used for conveyor belt placement

    const money_elem = document.getElementById('money');
    let money = 100000

    let autobuy_buildings = [];
    let autosell_buildings = [];
    let autocraft_buildings = [];
    // Draw the grid
    function drawGrid() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = 'lightgray';
      for (let x = 0; x < width; x++) {
        for (let y = 0; y < height; y++) {
          ctx.strokeRect(x * gridSize, y * gridSize, gridSize, gridSize);
        }
      }
    }

    // Draw buildings with inventory
    function drawBuildings() {
      buildings.forEach(building => {
        ctx.fillStyle = building.color;
        ctx.fillRect(building.x * gridSize, building.y * gridSize, gridSize, gridSize);
        ctx.fillStyle = 'white';
        ctx.fillText(`${building.type} (${building.inventory})`, building.x * gridSize + 2, building.y * gridSize + 8);
        //console.log(building.type)
        //console.log(building.inventory)
        //console.log(building);
      });
    }

    // Draw conveyor belts
    function drawConveyorBelts() {
      ctx.strokeStyle = 'red';
      ctx.lineWidth = 2;
      conveyorBelts.forEach(belt => {
        ctx.beginPath();
        ctx.moveTo(belt.start.x * gridSize + gridSize / 2, belt.start.y * gridSize + gridSize / 2);
        ctx.lineTo(belt.end.x * gridSize + gridSize / 2, belt.end.y * gridSize + gridSize / 2);
        ctx.stroke();
      });
    }

    // Draw moving items along conveyor belts
    function drawMovingItems() {
      movingItems.forEach(item => {
        ctx.fillStyle = item.color;
        ctx.beginPath();
        ctx.arc(
          item.currentX * gridSize,
          item.currentY * gridSize,
          gridSize / 4, // Radius of the circle
          0,
          2 * Math.PI
        );
        ctx.fill();
      });
    }

    function has_inventory(building) {
      for (const item in building.inventory) {
        if (building.inventory[item] > 0) {
          return true;
        }
      }
      return false
    }

    //game_loop
    setInterval(() => {
      money_elem.innerHTML = "Money: " + money.toString();

      autobuy_buildings.forEach(building => {
        if (money > building["recipe"]["price"]) {
          money -= building["recipe"]["price"]
          building["inventory"][building["recipe"]["name"]] += 1
        }
      });

      autosell_buildings.forEach(building => {
        if (building["inventory"][building["recipe"]["name"]] > 0) {
          building["inventory"][building["recipe"]["name"]]--;
          money += building["recipe"]["price"]
        }
      });

      autocraft_buildings.forEach(building => {
        flag = true;
        for (const material in building["recipe"]["recipe"]) {
          if (building["inventory"][material] < building["recipe"]["recipe"][material]) {
            flag = false;
          }
        };
        if (flag) {
          for (const material in building["recipe"]["recipe"]) {
            building["inventory"][material] -= building["recipe"]["recipe"][material];
          };

          building["inventory"][building["recipe"]["name"]]++;
        }
      });


      //Check Belts to put items on and take out of buildings
      conveyorBelts.forEach(belt => {
        const startBuilding = buildings.find(b => b.x === belt.start.x && b.y === belt.start.y);
        const endBuilding = buildings.find(b => b.x === belt.end.x && b.y === belt.end.y);
        let item_type;
        if (startBuilding && endBuilding && has_inventory(startBuilding)) {
          // Move one item from start to end
          if (startBuilding["type"] === "constructor") {
            if (startBuilding.inventory[startBuilding["recipe"]["name"]] > 0) {
              item_type = startBuilding["recipe"]["name"];
              startBuilding.inventory[startBuilding["recipe"]["name"]]--;
            }
          } else {
            for (const item in startBuilding.inventory) {
              if (startBuilding.inventory[item] > 0) {
                item_type = item;
                startBuilding.inventory[item]--;
              }
            };
          }
          // Create a moving item to represent the transfer
          const item = {
            startBuilding: startBuilding,
            endBuilding: endBuilding,
            type: item_type,
            color:
              item_type === 'steel'
                ? 'blue'
                : item_type === 'copper'
                ? 'orange'
                : 'green',
            startX: belt.start.x,
            startY: belt.start.y,
            endX: belt.end.x,
            endY: belt.end.y,
            currentX: belt.start.x,
            currentY: belt.start.y,
            progress: 0 // Represents progress along the belt
          };

          movingItems.push(item);
        }
      });

      const step = 0.05; // Smaller values make the animation smoother

      movingItems.forEach(item => {
        if (item.progress < 1) {
          item.progress += step;
          item.currentX = item.startX + item.progress * (item.endX - item.startX);
          item.currentY = item.startY + item.progress * (item.endY - item.startY);
        } else {
          // Remove completed items from the array
          item.endBuilding.inventory[item.type]++;
          movingItems.splice(movingItems.indexOf(item), 1)
        }
      });

      draw(); // Redraw the canvas
    }, 1000); // Adjust time interval to control movement frequency


    // Function to place a building
    function placeBuilding(type, x, y) {
      let color;
      let inv = {
        "Steel": 0,
        "Copper": 0,
        "Plating": 0,
        "Wire": 0,
        "Battery": 0,
        "Motor": 0,
        "Circuit": 0,
        "Laser Optics": 0,
        "Engine": 0,
        "Gunnery Weapon": 0,
        "Cannon Weapon": 0,
        "Laser Weapon": 0,
        "Gunnery Ship": 0,
        "Cannon Ship": 0,
        "Laser Ship": 0,
      };
      switch (type) {
        case 'steel':
          color = 'blue';
          inv["Steel"] = Infinity;
          break;
        case 'copper':
          color = 'orange';
          inv["Copper"] = Infinity;
          break;
        case 'storage':
          color = 'lightblue';
          break;
        case 'autoshop':
          color = 'green';
          buildings.push({ type, x, y, color, inventory: inv , buy_or_sell: null});
          return;
        case 'constructor':
          color = 'grey';
          buildings.push({ type, x, y, color, inventory: inv , recipe: null});
          return;
      }

      buildings.push({ type, x, y, color, inventory: inv });
    }

    // Function to add conveyor belts
    function addConveyorBelt(start, end) {
      conveyorBelts.push({ start, end });
    }

    // Function to set the current tool
    function setCurrentTool(tool) {
      currentTool = tool;
    }

    // Handle canvas clicks for building placement
    canvas.addEventListener('click', event => {
      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      const gridX = Math.floor(x / gridSize);
      const gridY = Math.floor(y / gridSize);
      
      // MOUSE
      if (currentTool === 'mouse') {
        get_building = placement_conflict(gridX, gridY);
        if (get_building) { // if we hit a building, show prompt
          document.getElementById('interface').style.display = 'block';
          
          var invText = ''; // add inventory to display
          for (const item in get_building.inventory) {
            invText += `<br>&nbsp;${item} &#x21E8; ${get_building.inventory[item]}`; // added special stuff for HTML conversion
          }

          if (get_building.type === 'constructor') {
            disp_constructor(get_building, invText);
          } else if (get_building.type === 'autoshop') {
            disp_shop(get_building, invText);
          } else {
            // display text using HTML assistance
            document.getElementById('interface').innerHTML = get_building.type.toUpperCase() + "<br><br>Inventory<br>&nbsp;&nbsp;" + invText;
          }
        } else {
          document.getElementById('interface').style.display = 'none';
        }
      // CONVEYOR
      } else if (currentTool === 'conveyor') {
        if (!firstClick) {
          firstClick = { x: gridX, y: gridY };
        } else {
          const start = firstClick;
          const end = { x: gridX, y: gridY };

          if (start !== end && placement_conflict(start.x, start.y) && placement_conflict(end.x, end.y)) { // add conveyor if start & end valid obj
            let all_clear = check_conveyor_rules(start, end);
            if (all_clear) {
              addConveyorBelt(start, end); // Add a new conveyor belt
            }
          }

          firstClick = null;
        }
      // DELETE
      } else if (currentTool === 'delete' && buildings) {
        del_building = placement_conflict(gridX, gridY);
        if (del_building) {
          // del conveyors attached to building
          conveyorBelts.forEach((belt, idx) => {
            if (belt.start.x === del_building.x && belt.start.y === del_building.y || belt.end.x === del_building.x && belt.end.y === del_building.y) {
              conveyorBelts.splice(idx, 1);
            }
          });
          // del building
          let b_idx = buildings.indexOf(del_building);
          buildings.splice(b_idx, 1);
        }
      } else {
        if (currentTool && !(placement_conflict(gridX, gridY))) { // make sure new building doesn't conflict with others
          placeBuilding(currentTool, gridX, gridY);
        }
      }

      draw(); // Redraw the canvas
    });

    function disp_constructor(c, invT) {
      if (c.recipe) { // show menu to choose recipe for constructor if recipe not chosen
        document.getElementById('interface').innerHTML = c.type.toUpperCase() + "<br><br>Inventory<br>&nbsp;&nbsp;" + invT + "<br><br>Recipe<br><br>&nbsp;&nbsp;" + c.recipe.name;
        return;
      }

      // creating drop down menu to select recipe
      var dropdownHTML = '<select id="dropdown">';
      var dropdownOptions = [];
      
      for(var key in Recipe_dict) {
        dropdownOptions.push(key)
      }
      dropdownHTML += '<option value=" "</option>';
      dropdownOptions.forEach(function(option) {
          dropdownHTML += '<option value="' + option + '">' + option + '</option>';
      });
      dropdownHTML += '</select>';      
      document.getElementById('interface').innerHTML = c.type.toUpperCase() + "<br><br>Inventory<br>&nbsp;&nbsp;" + invT + "<br><br>Recipe<br>" + dropdownHTML;

      // once dropdown chosen, make it the recipe (call event listener to see what's chosen)
      var dropdown = document.getElementById('dropdown');
      dropdown.addEventListener('change', function() {
          c.recipe = {
            name: this.value, 
            recipe: Recipe_dict[this.value]
          };
          console.log(c.recipe);
          autocraft_buildings.push(c)
      });
    }

    function disp_shop(building, invT) {
      if (building.buy_or_sell && building.recipe) { 
        document.getElementById('interface').innerHTML = building.type.toUpperCase() + "<br><br>Inventory<br>&nbsp;&nbsp;" + invT + "<br><br>Buy or Sell<br><br>&nbsp;&nbsp;" + building.buy_or_sell + "<br><br>Recipe<br><br>&nbsp;&nbsp;" + building.recipe.name;
        return;
      }
      
      // creating drop down menu to select state
      var shopdropdownHTML = '<select id="shopdropdown">';
      var shopdropdownOptions = ["sell", "buy"];
      
      shopdropdownHTML += '<option value=" "</option>';
      shopdropdownOptions.forEach(function(option) {
        shopdropdownHTML += '<option value="' + option + '">' + option + '</option>';
      });
      shopdropdownHTML += '</select>';      
      

      var recipedropdownHTML = '<select id="recipedropdown">';
      var recipedropdownOptions = [];
      
      for(var key in Recipe_dict) {
        recipedropdownOptions.push(key)
      }
      recipedropdownHTML += '<option value=" "</option>';
      recipedropdownOptions.forEach(function(option) {
        recipedropdownHTML += '<option value="' + option + '">' + option + '</option>';
      });
      recipedropdownHTML += '</select>';      
      
      document.getElementById('interface').innerHTML = building.type.toUpperCase() + "<br><br>Inventory<br>&nbsp;&nbsp;" + invT + "<br><br>Buy or Sell?<br>" + shopdropdownHTML + "<br><br>recipe<br>" + recipedropdownHTML;

      // once dropdown chosen, make it the state (call event listener to see what's chosen)
      var dropdown = document.getElementById('shopdropdown');
      dropdown.addEventListener('change', function() {
        building.buy_or_sell = this.value;
        if (this.value === "buy") {
          autobuy_buildings.push(building)
        } else {
          autosell_buildings.push(building)
        }
        console.log(building.state);
      });

      var dropdown = document.getElementById('recipedropdown');
      dropdown.addEventListener('change', function() {
        building.recipe = {
          name: this.value, 
          price: base_price[this.value]
        };
        console.log(building.recipe);
        building.inventory[building.recipe.name] = 0;
      });
    }

    // Draw the canvas (grid, buildings, belts, and moving items)
    function draw() {
      drawGrid();
      drawBuildings();
      drawConveyorBelts();
      drawMovingItems(); // Draw the moving items across belts
    }

    function placement_conflict(x, y) {
      // check if our curr click hits an existing obj
      conflict = false;

      buildings.forEach(building => {    
        if (building.x == x && building.y == y) {
          conflict = building;
        }
      });
      
      return conflict;
    }

    function check_conveyor_rules(start_obj, end_obj) {
      //let valid = true;
      
      const startBuilding = buildings.find(b => b.x === start_obj.x && b.y === start_obj.y);
      const endBuilding = buildings.find(b => b.x === end_obj.x && b.y === end_obj.y);
      
      // (1) cannot connect 2 buildings of same type by conveyor unless they are both constructors
      if (startBuilding.type === endBuilding.type && (startBuilding.type != 'constructor' && endBuilding.type != 'constructor')) {
        console.log("cannot connect 2 buildings of same type by conveyor unless they are both constructors")
        return false;
      }
      // (2) cannot make copper or steel landing pads an endpoint for a conveyor belt
      if (endBuilding.type === 'copper' || endBuilding.type === 'steel') {
        console.log("cannot make copper or steel landing pads an endpoint for a conveyor belt")
        return false;
      }
      // (3) cannot make a storage (placeholder for shops and launch pads) be a starting point for a conveyor
      if (startBuilding.type === 'storage') {
        console.log("cannot make a storage (placeholder for shops and launch pads) be a starting point for a conveyor")
        return false;
      }

      // (4) only let a constructor-constructor if [end constructor] recipe requires [start constructor] item
      // (5) only allow storage to connect to constructor of a finished product (for launching to David)
      
      return true;
    }

    // Initial draw
    draw();

  </script>
</body>
</html>
