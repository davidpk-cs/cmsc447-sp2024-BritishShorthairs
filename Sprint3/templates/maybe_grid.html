<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Factorio-like Game with Moving Items</title>
  <style>
    canvas {
      border: 1px solid black;
    }
    .toolbox {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      background-color: #f4f4f4;
      padding: 10px;
      display: flex;
      justify-content: center;
    }
    .toolbox button {
      margin: 0 10px;
    }
    #interface {
      display: none; /* hide by default */
      width: 200px;
      height: 150px;
      background-color: rgb(203, 177, 132);
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 20px;
      border-radius: 10px;
      border-top: 5px solid #000;
      /* init pos */
      top: 200px; 
      left: 700px; 
    }
  </style>
</head>
<body>
  <canvas id="canvas" width="500" height="500"></canvas>
  <div class="toolbox">
    <button onclick="setCurrentTool('steel')">Steel Source</button>
    <button onclick="setCurrentTool('copper')">Copper Source</button>
    <button onclick="setCurrentTool('storage')">Storage</button>
    <button onclick="setCurrentTool('constructor')">Constructor</button>
    <button onclick="setCurrentTool('conveyor')">Conveyor Belt</button>
    <button onclick="setCurrentTool('mouse')">Mouse</button>
  </div>

  <!-- Interface elements -->
  <div id="interface"></div>

  <script src="info.js"></script>
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const gridSize = 20; // Size of each grid cell in pixels
    const width = 25;  // Number of columns
    const height = 25; // Number of rows

    const buildings = [];
    const conveyorBelts = [];
    const movingItems = []; // Tracks items moving along conveyors
    let currentTool = null; // Current tool/building selected
    let firstClick = null; // Used for conveyor belt placement

    // Draw the grid
    function drawGrid() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = 'lightgray';
      for (let x = 0; x < width; x++) {
        for (let y = 0; y < height; y++) {
          ctx.strokeRect(x * gridSize, y * gridSize, gridSize, gridSize);
        }
      }
    }

    // Draw buildings with inventory
    function drawBuildings() {
      buildings.forEach(building => {
        ctx.fillStyle = building.color;
        ctx.fillRect(building.x * gridSize, building.y * gridSize, gridSize, gridSize);
        ctx.fillStyle = 'white';
        ctx.fillText(`${building.type} (${building.inventory})`, building.x * gridSize + 2, building.y * gridSize + 8);
        console.log(building.type)
        console.log(building.inventory)
        //console.log(buildings.length);
      });
    }

    // Draw conveyor belts
    function drawConveyorBelts() {
      ctx.strokeStyle = 'red';
      ctx.lineWidth = 2;
      conveyorBelts.forEach(belt => {
        ctx.beginPath();
        ctx.moveTo(belt.start.x * gridSize + gridSize / 2, belt.start.y * gridSize + gridSize / 2);
        ctx.lineTo(belt.end.x * gridSize + gridSize / 2, belt.end.y * gridSize + gridSize / 2);
        ctx.stroke();
      });
    }

    // Draw moving items along conveyor belts
    function drawMovingItems() {
      movingItems.forEach(item => {
        ctx.fillStyle = item.color;
        ctx.beginPath();
        ctx.arc(
          item.currentX * gridSize,
          item.currentY * gridSize,
          gridSize / 4, // Radius of the circle
          0,
          2 * Math.PI
        );
        ctx.fill();
      });
    }

    function has_inventory(building) {
      for (const item in building.inventory) {
        if (building.inventory[item] > 0) {
          return true;
        }
      }
      return false
    }

    //game_loop
    setInterval(() => {

      //Check Belts to put items on and take out of buildings
      conveyorBelts.forEach(belt => {
        const startBuilding = buildings.find(b => b.x === belt.start.x && b.y === belt.start.y);
        const endBuilding = buildings.find(b => b.x === belt.end.x && b.y === belt.end.y);
        let item_type;
        if (startBuilding && endBuilding && has_inventory(startBuilding)) {
          // Move one item from start to end
          for (const item in startBuilding.inventory) {
            if (startBuilding.inventory[item] > 0) {
              item_type = item;
              startBuilding.inventory[item]--;

            }
          };

          // Create a moving item to represent the transfer
          const item = {
            startBuilding: startBuilding,
            endBuilding: endBuilding,
            type: item_type,
            color:
              item_type === 'steel'
                ? 'blue'
                : item_type === 'copper'
                ? 'orange'
                : 'green',
            startX: belt.start.x,
            startY: belt.start.y,
            endX: belt.end.x,
            endY: belt.end.y,
            currentX: belt.start.x,
            currentY: belt.start.y,
            progress: 0 // Represents progress along the belt
          };

          movingItems.push(item);
        }
      });

      const step = 0.05; // Smaller values make the animation smoother

      movingItems.forEach(item => {
        if (item.progress < 1) {
          item.progress += step;
          item.currentX = item.startX + item.progress * (item.endX - item.startX);
          item.currentY = item.startY + item.progress * (item.endY - item.startY);
        } else {
          // Remove completed items from the array
          item.endBuilding.inventory[item.type]++;
          movingItems.splice(movingItems.indexOf(item), 1)
        }
      });

      draw(); // Redraw the canvas
    }, 1000); // Adjust time interval to control movement frequency


    // Function to place a building
    function placeBuilding(type, x, y) {
      let color;
      let inv = {steel: 0, copper:0, circuit:0};
      switch (type) {
        case 'steel':
          color = 'blue';
          inv.steel = Infinity;
          break;
        case 'copper':
          color = 'orange';
          inv.copper = Infinity;
          break;
        case 'storage':
          color = 'lightblue';
          break;
        case 'constructor':
          color = 'green';
          break;
      }

      buildings.push({ type, x, y, color, inventory: inv });
    }

    // Function to add conveyor belts
    function addConveyorBelt(start, end) {
      conveyorBelts.push({ start, end });
    }

    // Function to set the current tool
    function setCurrentTool(tool) {
      currentTool = tool;
    }

    // Handle canvas clicks for building placement
    canvas.addEventListener('click', event => {
      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      const gridX = Math.floor(x / gridSize);
      const gridY = Math.floor(y / gridSize);

      if (currentTool === 'mouse') {
        get_building = placement_conflict(gridX, gridY);
        if (get_building) { // if we hit a building, show prompt
          document.getElementById('interface').style.display = 'block';

          var invText = ''; // add inventory to display
          for (const item in get_building.inventory) {
            console.log(get_building.inventory[item]);
            invText += `\n\t${item}: ${get_building.inventory[item]}`;
          }
          // display text
          document.getElementById('interface').textContent = 'Building Name:\n\t' + get_building.type + "\nInventory:\n\t" + invText;
        } else {
          document.getElementById('interface').style.display = 'none';
        }
      }

      else if (currentTool === 'conveyor') {
        if (!firstClick) {
          firstClick = { x: gridX, y: gridY };
        } else {
          const start = firstClick;
          const end = { x: gridX, y: gridY };

          if (start !== end && placement_conflict(start.x, start.y) && placement_conflict(end.x, end.y)) { // add conveyor if start & end valid obj
            let all_clear = check_conveyor_rules(start, end);
            if (all_clear) {
              addConveyorBelt(start, end); // Add a new conveyor belt
            }
          }

          firstClick = null;
        }
      } else {
        if (currentTool && !(placement_conflict(gridX, gridY))) { // make sure new building doesn't conflict with others
          placeBuilding(currentTool, gridX, gridY);
        }
      }

      draw(); // Redraw the canvas
    });

    // Draw the canvas (grid, buildings, belts, and moving items)
    function draw() {
      drawGrid();
      drawBuildings();
      drawConveyorBelts();
      drawMovingItems(); // Draw the moving items across belts
    }

    function placement_conflict(x, y) {
      // check if our curr click hits an existing obj
      conflict = false;

      buildings.forEach(building => {    
        console.log(building.x, x, building.y, y);
        if (building.x == x && building.y == y) {
          conflict = building;
        }
      });
      
      return conflict;
    }

    function check_conveyor_rules(start_obj, end_obj) {
      //let valid = true;
      
      const startBuilding = buildings.find(b => b.x === start_obj.x && b.y === start_obj.y);
      const endBuilding = buildings.find(b => b.x === end_obj.x && b.y === end_obj.y);
      
      // (1) cannot connect 2 buildings of same type by conveyor unless they are both constructors
      if (startBuilding.type === endBuilding.type && (startBuilding.type != 'constructor' && endBuilding.type != 'constructor')) {
        return false;
      }
      // (2) cannot make copper or steel landing pads an endpoint for a conveyor belt
      if (endBuilding.type === 'copper' || endBuilding.type === 'steel') {
        return false;
      }
      // (3) cannot make a storage (placeholder for shops and launch pads) be a starting point for a conveyor
      if (startBuilding.type === 'storage') {
        return false;
      }

      // (4) only let a constructor-constructor if [end constructor] recipe requires [start constructor] item
      // (5) only allow storage to connect to constructor of a finished product (for launching to David)
      
      return true;
    }

    // Initial draw
    draw();

  </script>
</body>
</html>
