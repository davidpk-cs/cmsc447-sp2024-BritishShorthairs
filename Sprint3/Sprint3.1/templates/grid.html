<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Grid Drawing</title>
<style>
canvas {
  border: 1px solid black;
}
#toolbox {
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;
  background-color: #f4f4f4;
  padding: 10px 0;
  box-shadow: 0 -2px 5px rgba(0,0,0,0.2);
  display: flex;
  justify-content: left;
}

#toolbox button {
  margin: 0 5px;
}

.tooltip {
  position: absolute;
  background-color: rgba(0, 0, 0, 0.7);
  color: white;
  padding: 15px;
  border-radius: 15px;
  pointer-events: none; /* Ensures the tooltip does not interfere with mouse events */
  display: none; /* Initially hide the tooltip */
}

</style>
</head>
<body>
<canvas id="canvas" width="500" height="500"></canvas>
<div id="tooltip" class="tooltip"></div>

<div id="toolbox">
  <button onclick='change_button("1")'>Small Box</button>
  <button onclick='change_button("2")'>Medium Box</button>
  <button onclick='change_button("3")'>Large Box</button>
  <button onclick='load_line()'>Conveyer</button>
  <button onclick='load_mouse()'>Mouse</button>
  <button onclick='drawBoard()'>Refresh</button>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

//-----------------------Globals-----------------------------------

let bounds = ""
var startX = 0;
var startY = 0;
var mouseX = 0;
var mouseY = 0;
var startObj = null;
var endObj = null;
var isDrawing = false;
var existingLines = [];
const item_coords = [];
const size = {"x": 64, "y": 28}
const pixel_size = window.innerWidth * .96 / size.x; // Size of the grid cell

var tooltip = document.getElementById("tooltip");


// canvas dim, rounded to not cut off cells
canvas.width = size.x * pixel_size;
canvas.height = size.y * pixel_size;

null_building = {
  x: 0, y:0, color:"white",
  type: "null_building",
  image_path: "",
  setting: ""
}
constructor_building = {
  x: 3, y:3, color:"blue",
  type: "constructor",
  image_path: "",
  setting: ""
}
pad_building = {
  x: 6, y: 6, color:"red",
  type: "pad",
  image_path: "",
  setting: ""
}
shop_building = {
  x: 6, y:4, color:"green",
  type: "shop",
  image_path: "",
  setting: ""
}

curr_building = constructor_building;

mouse_is_active = false;

//-----------------------Game funct-----------------------------------

const drawBoard = () => {

  console.log(item_coords)
  // clear the canvas before a redraw
  ctx.clearRect(0, 0,
                canvas.width, canvas.height);
  //ctx.fillStyle = "#ffffff";
  //ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.lineWidth = 1;

  // redraw the lines
  for (let x = 0; x <= canvas.width + pixel_size; x += pixel_size) { 
    for (let y = 0; y <= canvas.height + pixel_size; y += pixel_size) {
      ctx.strokeStyle = "black";
      ctx.strokeRect(x, y, pixel_size, pixel_size);
    }
  }
  
  // redraw all items
  item_coords.forEach(stored_item => {
    //console.log(stored_item) 
    drawRect(stored_item.x, stored_item.y, stored_item.building, false)
  });
  //ctx.stroke();


  ctx.strokeStyle = "black";
  ctx.lineWidth = 10;
  ctx.beginPath();
  
  for (var i = 0; i < existingLines.length; ++i) { // redraw conveyors
    var line = existingLines[i];
    // // console.log("STORED LINE OBJECTS: ", line.obj_1, line.obj_2);
    // ctx.moveTo(line.startX,line.startY);
    // ctx.lineTo(line.endX,line.endY);
    canvas_arrow(20, line.startX, line.startY, line.endX, line.endY)

  }
  ctx.stroke();
};

const drawRect = (x, y, building, new_box=true) => {
  ctx.fillStyle = building.color;
  //console.log('Clicked pos rect: ', x, y); // check console on web 

  // Check if any object conflicts with where we clicked for new 
  conflict = false;
  if (new_box){
    conflict = placement_conflict(x, y)
  }
  console.log(conflict)
  // only create a rect and store it if no conflict
  if (!conflict) {
    ctx.fillStyle = building.color;
    ctx.fillRect(x * pixel_size, y * pixel_size, 
               pixel_size * building.y, pixel_size * building.x);
  
    // store rect here (top left corner, and its width and height)
    const item = {
          x: x,
          y: y,
          building: curr_building,
          connectors: 0,
          tooltipVisible: false
      };

    // Push rectangle object to the array
    // Check if any object conflicts with where we clicked for new 
    if (new_box){
      item_coords.push(item);
    }
  }
};

const placement_conflict = (x, y) => {
  // make an arbitrary rect for new item
  r_x = x + curr_building.x - 1; 
  b_y = y + curr_building.y - 1;
  // console.log("Curr box: ", x, y, r_x, y, x, b_y, r_x, b_y);

  // conflict: right x-coords are > grid right boundary (grid's max x)
  if (r_x > right_grid_boundary_x) {
    return true;
  }

  // conflict: lower y-coords < the grid bottom boundary (grid's max y)
  if (b_y > bottom_grid_boundary_y) {
    return true;
  }

  // conflict with existing items
  conflict = false;

  item_coords.forEach(stored_item => {    
    r_x2 = stored_item.x + stored_item.building.x - 1; 
    b_y2 = stored_item.y + stored_item.building.y - 1;

    // console.log("existing box: ", stored_item.x, stored_item.y, r_x2, stored_item.y, stored_item.x, b_y2, r_x2, b_y2);

    // conflict when curr_building inhibits an exisiting box
    if (!(x > r_x2 || r_x < stored_item.x)) { 
      if (!(y > b_y2 || b_y < stored_item.y)) {
        conflict = stored_item;
      }
    }
  });

  return conflict;
};

const round_to_grid = (coord) => {
  return Math.floor(coord / pixel_size);
};

const dump_obj = () => { // adapt this later to send objects somewhere else or reload them
  item_coords.forEach(stored_item => {    
    console.log(stored_item.x, stored_item.y, stored_item.building.x, stored_item.building.y)
  });
};

canvas.addEventListener('click', (event) => {
  const rect = canvas.getBoundingClientRect();
  bounds = canvas.getBoundingClientRect();
  const x = event.clientX - rect.left;
  const y = event.clientY - rect.top;

  const gridX = round_to_grid(x);
  const gridY = round_to_grid(y);

  drawRect(gridX, gridY, curr_building);
});

canvas.addEventListener('click', (event) => { // mouse click on object
  const rect = canvas.getBoundingClientRect();
  bounds = canvas.getBoundingClientRect();
  const x = event.clientX - rect.left;
  const y = event.clientY - rect.top;

  const gridX = round_to_grid(x);
  const gridY = round_to_grid(y);

  let found_obj = click_in_box(gridX, gridY);

  if (found_obj && mouse_is_active) { // create textbox if hit object
    if (!(found_obj.tooltipVisible)) {
      tooltip.style.display = "block";
      tooltip.textContent = found_obj.building.type;
      tooltip.style.left = event.clientX + 10 + "px";
      tooltip.style.top = event.clientY + 10 + "px";
      found_obj.tooltipVisible = true;
    } else { // enable textbox removal on double click
      found_obj.tooltipVisible = false;
      tooltip.style.display = "none";
    }
    
  } else { // when we click off box, disable textbox, adjust this later?
    tooltip.style.display = "none";
  }
});

//-----------------------Starting grid-----------------------------------

drawBoard(); // instantiate board

// get borders of grid
const right_grid_boundary_x = round_to_grid(canvas.width) - 1;
const bottom_grid_boundary_y = round_to_grid(canvas.height) - 1;

//-----------------------Other functs-----------------------------------

function change_button(x) {
  unload_line()
  console.log(x)
  if (x === "1") {
    curr_building = constructor_building
  } else if (x === "2") {
    curr_building = pad_building
  } else if (x === "3") {
    curr_building = shop_building
  }
}

function redirect_page() {
  console.log("Redirecting...")
  window.location.href='/';
}

function draw() {
  drawBoard();
  
  if (isDrawing) {
    ctx.strokeStyle = "darkred";
    ctx.lineWidth = 3;
    ctx.beginPath();
    // ctx.moveTo(startX,startY);
    // ctx.lineTo(mouseX,mouseY);
    canvas_arrow(startX, startY, mouseX, mouseY)
    ctx.stroke();
  }
  
}

function canvas_arrow(headlen=10, fromx, fromy, tox, toy) {
  var dx = tox - fromx;
  var dy = toy - fromy;
  var angle = Math.atan2(dy, dx);
  ctx.moveTo(fromx, fromy);
  ctx.lineTo(tox, toy);
  ctx.lineTo(tox - headlen * Math.cos(angle - Math.PI / 6), toy - headlen * Math.sin(angle - Math.PI / 6));
  ctx.moveTo(tox, toy);
  ctx.lineTo(tox - headlen * Math.cos(angle + Math.PI / 6), toy - headlen * Math.sin(angle + Math.PI / 6));
}

function click_in_box(x, y) { // detect mouse inside of existing objects
  let clicked = false;
  item_coords.forEach(stored_item => { 
    if ((x >= stored_item.x && x <= (stored_item.x + stored_item.building.x - 1)) && (y >= stored_item.y && y <= (stored_item.y + stored_item.building.y - 1))) {
      clicked = stored_item; // return the item if valid
    }       
  });

  return clicked;
}

function onmousedown(e) {
  if (hasLoaded && e.button === 0) {
    if (!isDrawing) {
      startX = e.clientX - bounds.left;
      startY = e.clientY - bounds.top;
      
      s_X = round_to_grid(startX);
      s_Y = round_to_grid(startY);

      console.log("CHECK MOUSE DOWN: ", s_X, s_Y);
      valid_start = click_in_box(s_X, s_Y); // only draw if selecting conveyor from valid obj
      if (valid_start) {
        startObj = valid_start; 
        isDrawing = true;
      }
    }
    draw();
  }
}

function onmouseup(e) {
  if (hasLoaded && e.button === 0) {
    if (isDrawing) {
      // only finish line if endpoint is valid obj
      let valid_line_end = click_in_box(round_to_grid(mouseX), round_to_grid(mouseY));  
      if (valid_line_end && valid_line_end != startObj) {
        // create line and store objects it connects
        existingLines.push({
        startX: startX,
        startY: startY,
        endX: mouseX,
        endY: mouseY,
        obj_1: startObj,
        obj_2: valid_line_end
        });
        
        startObj.connectors += 1; // increment connectors for obj (don't exceed max for an obj)
        valid_line_end.connectors += 1;
        
        startObj = null; // reset
        endObj = null;
      }
      isDrawing = false;
    } 
    draw();
  }
}

function onmousemove(e) {
  if (hasLoaded) {
    mouseX = e.clientX - bounds.left;
    mouseY = e.clientY - bounds.top;
    
    if (isDrawing) {
      draw();
    }
  }
}

function load_line() {
  curr_building = null_building
  canvas.onmousedown = onmousedown;
  canvas.onmouseup = onmouseup;
  canvas.onmousemove = onmousemove;
  
  hasLoaded = true; 
}

function unload_line() {
  canvas.onmousedown = false;
  canvas.onmouseup = false;
  canvas.onmousemove = false;
  
  hasLoaded = true; 
}

function load_mouse() {
  curr_building = null_building
  mouse_is_active = true;
} 

</script>
</body>
</html>
